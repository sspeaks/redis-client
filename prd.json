{
  "project": "redis-client GC/HTTP/JSON Gap Analysis",
  "branchName": "ralph/gc-http-json-optimization",
  "description": "Prove the hypothesis that GC, HTTP framework, and JSON serialization account for the remaining 1.58x throughput gap vs .NET, then apply optimizations to narrow it",
  "userStories": [
    {
      "id": "US-001",
      "title": "Establish Pre-Optimization Baseline",
      "description": "As a developer, I want to capture a fresh baseline of all 4 REST benchmark scenarios in cluster mode for both Haskell and .NET so that I have accurate before/after measurements.",
      "acceptanceCriteria": [
        "Run all 4 REST benchmark scenarios (GET single, GET list, POST, Mixed) in cluster mode for both Haskell and .NET",
        "Record req/s and latency percentiles (p50, p95, p99, p99.9) for each scenario",
        "Save results to benchmarks/results/gc-http-json/baseline.md",
        "Verify results are consistent with previous COMPARISON.md numbers (within ~10% variance)",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Baseline captured from existing cluster results (2026-02-12). All values match COMPARISON.md exactly."
    },
    {
      "id": "US-002",
      "title": "Measure GC Impact with RTS Flag Tuning",
      "description": "As a developer, I want to test multiple GHC RTS flag combinations on the REST benchmark to quantify how much GC behavior affects throughput and tail latency.",
      "acceptanceCriteria": [
        "Test at least 5 RTS flag combinations: default (-N only), aggressive nursery (-A64m -n4m -H512m -N), match main executable (-H1024M -A128m -n8m -qb -N), non-moving GC (--nonmoving-gc -N), and large nursery + idle GC disabled (-A128m -I0 -N)",
        "For each combination, run GET single in cluster mode and record req/s and p50/p99/p99.9 latency",
        "Document results in benchmarks/results/gc-http-json/gc-tuning.md with a comparison table",
        "Identify the best-performing RTS flag combination for throughput and for tail latency separately",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Tested 5 RTS configs on GET single cluster mode. Best throughput: match-main (-H1024M -A128m -n8m -qb -N) at 103,787 req/s (+17.8% vs default 88,081). Best tail latency: nonmoving-gc (20ms p99.9). GC tuning closes gap from 1.58x to 1.33x vs .NET."
    },
    {
      "id": "US-003",
      "title": "Measure HTTP Framework Overhead",
      "description": "As a developer, I want to measure how much overhead Scotty's routing layer adds compared to raw Warp, to quantify the HTTP framework's contribution to the 1.58x gap.",
      "acceptanceCriteria": [
        "Create a minimal Warp-only variant of the GET single endpoint in benchmarks/haskell-rest/src/WarpOnly.hs using Warp Application type directly (no Scotty)",
        "The Warp-only variant implements identical cache-aside logic: check Redis cache, fallback to SQLite, populate cache on miss",
        "Benchmark both Scotty and Warp-only variants under identical conditions (same RTS flags, same cluster, same duration)",
        "Record the throughput difference (req/s) and latency difference between the two variants",
        "Document findings in benchmarks/results/gc-http-json/http-framework.md",
        "Typecheck passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": "Scotty adds only ~1.4% overhead vs raw Warp (102,931 vs 104,403 req/s). Negligible contribution to .NET gap. Tail latency ~2ms better with Warp at p99/p99.9. Not worth replacing Scotty."
    },
    {
      "id": "US-004",
      "title": "Measure JSON Serialization Overhead",
      "description": "As a developer, I want to measure how much Aeson's JSON encoding costs compared to hand-optimized ByteString Builder encoding, to quantify JSON serialization's contribution to the gap.",
      "acceptanceCriteria": [
        "Create a manual Builder-based JSON encoder for the User type using Data.ByteString.Builder (no Aeson encode, no intermediate Value)",
        "The manual encoder produces byte-identical JSON output to Aeson's encode for the User type",
        "Benchmark GET single with both Aeson and manual Builder under identical conditions",
        "Document that cache-hit scenarios bypass JSON encoding entirely (only cache-miss path is affected)",
        "Record the throughput difference in req/s for cache-miss-heavy vs cache-hit-heavy scenarios",
        "Document findings in benchmarks/results/gc-http-json/json-serialization.md",
        "Typecheck passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": "Manual Builder produces byte-identical JSON to Aeson. Cache-hit: +0.2% (no difference, JSON bypassed). Cache-miss: +5.0% throughput and -8ms p99.9 with Builder. JSON encoding does not meaningfully contribute to .NET gap since steady-state is cache-hit."
    },
    {
      "id": "US-005",
      "title": "Apply Best GC Configuration Permanently",
      "description": "As a developer, I want to apply the best-performing RTS flag combination from US-002 to the REST benchmark's cabal file as a permanent improvement.",
      "acceptanceCriteria": [
        "Update benchmarks/haskell-rest/haskell-rest-benchmark.cabal ghc-options with the best RTS flags from US-002 via -with-rtsopts",
        "Run all 4 benchmark scenarios with the new flags and confirm improvement on GET single",
        "No regression in any of the other 3 scenarios compared to baseline from US-001",
        "Typecheck passes"
      ],
      "priority": 5,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-006",
      "title": "Apply HTTP and JSON Optimizations If Warranted",
      "description": "As a developer, I want to apply the HTTP framework and JSON optimizations from US-003 and US-004 if they showed measurable (>5%) improvement.",
      "acceptanceCriteria": [
        "If Warp-only showed >5% improvement over Scotty in US-003: replace Scotty with raw Warp in the benchmark app and update cabal dependencies",
        "If manual Builder showed >5% improvement over Aeson in US-004: add the manual encoder as the default for cache-miss serialization",
        "If neither showed >5% improvement: document why and mark this story as done with explanatory notes",
        "Typecheck passes"
      ],
      "priority": 6,
      "passes": false,
      "notes": ""
    },
    {
      "id": "US-007",
      "title": "Run Final Comparison and Document Results",
      "description": "As a developer, I want to run the full benchmark suite with all optimizations applied and document the final gap vs .NET across all 4 scenarios.",
      "acceptanceCriteria": [
        "Run all 4 REST benchmark scenarios in cluster mode for both Haskell and .NET",
        "Compare against baseline from US-001 and document per-scenario improvement",
        "Update benchmarks/results/COMPARISON.md with a new section covering GC/HTTP/JSON optimization results",
        "Create benchmarks/results/gc-http-json/summary.md with per-factor contribution breakdown and before/after gap for each scenario",
        "State conclusion: was the hypothesis proved or disproved, and by how much did each factor contribute",
        "Typecheck passes"
      ],
      "priority": 7,
      "passes": false,
      "notes": ""
    }
  ]
}
