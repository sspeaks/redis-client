{
  "project": "redis-client",
  "branchName": "ralph/fair-rest-benchmark",
  "description": "Re-run REST+Redis benchmarks fairly with Haskell multiplexing enabled, fix broken POST/mixed scenarios, and produce a trustworthy comparison document with detailed analysis",
  "userStories": [
    {
      "id": "US-001",
      "title": "Rebase Benchmark Branch onto Multiplexing Branch",
      "description": "As a developer, I want the benchmark code rebased onto ralph/cluster-performance-parity so that the Haskell app can use the library's multiplexing features.",
      "acceptanceCriteria": [
        "New branch created from ralph/cluster-performance-parity containing all benchmark code",
        "All benchmark files from ralph/rest-cache-benchmark are present (benchmarks/, scripts, dotnet-rest, haskell-rest, etc.)",
        "cabal build haskell-rest-benchmark succeeds on the new branch",
        "dotnet build succeeds for the C# app",
        "The Multiplexer and MultiplexPool modules are available for import",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-002",
      "title": "Update Haskell App to Use Multiplexing",
      "description": "As a developer, I want the Haskell REST app to use the Multiplexer for standalone mode so that Redis commands are pipelined and multiplexed across concurrent requests, matching StackExchange.Redis's architecture.",
      "acceptanceCriteria": [
        "Standalone mode: creates a Multiplexer wrapping the PlainTextClient connection, all Redis commands go through submitCommand instead of evalStateT",
        "Multiple concurrent HTTP requests can execute Redis commands simultaneously without serialization",
        "The same cache-aside logic is preserved (GET checks cache, populates on miss with 60s TTL, writes invalidate)",
        "Redis key format remains user:{id} (identical to C# app)",
        "Cluster mode still works via ClusterClient (which already uses MultiplexPool)",
        "App starts and serves requests correctly on both standalone and cluster Redis",
        "cabal build succeeds",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-003",
      "title": "Fix POST Benchmark Scenario (Unique Emails)",
      "description": "As a developer, I want the POST benchmark to generate unique email addresses per request so that SQLite UNIQUE constraint violations don't cause 500 errors.",
      "acceptanceCriteria": [
        "The autocannon POST scenario generates unique emails per request (e.g., counter or timestamp-based)",
        "If autocannon CLI doesn't support dynamic bodies, the scenario uses the Node.js programmatic API to generate unique emails",
        "Running the POST benchmark produces >95% 2xx responses for both apps",
        "Both apps receive identical request patterns",
        "Typecheck passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-004",
      "title": "Fix Mixed Benchmark Scenario",
      "description": "As a developer, I want the mixed workload benchmark to produce valid results with realistic throughput so that we can compare mixed-workload performance.",
      "acceptanceCriteria": [
        "The mixed workload script generates unique emails for POST requests",
        "PUT and DELETE operations target valid user IDs within the seeded 1-10000 range",
        "Running the mixed benchmark produces throughput in the thousands of req/s range (not 7-46 req/s)",
        "Both apps receive identical request distribution (70% GET single, 10% GET list, 10% POST, 5% PUT, 5% DELETE)",
        "Non-2xx response rate is less than 5% for both apps",
        "Typecheck passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-005",
      "title": "Run Fair Standalone Benchmarks",
      "description": "As a developer, I want to run the full benchmark suite against standalone Redis with both apps using multiplexed connections so that I get trustworthy, fair numbers.",
      "acceptanceCriteria": [
        "Redis is running via Docker (standalone mode)",
        "SQLite database is freshly seeded with 10,000 users",
        "Haskell app is running with multiplexing enabled via Multiplexer",
        "C# app is running with StackExchange.Redis default multiplexing",
        "All 4 scenarios run successfully: GET single, GET list, POST, Mixed",
        "All scenarios produce >95% 2xx responses for both apps",
        "Results saved to benchmarks/results/standalone/",
        "If throughput difference exceeds 3x in any scenario, document investigation of what's different",
        "Typecheck passes"
      ],
      "priority": 5,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-006",
      "title": "Produce Fair Comparison Document",
      "description": "As a developer, I want a comparison document with actual benchmark data and thorough analysis explaining why the numbers differ, with extra scrutiny on large gaps.",
      "acceptanceCriteria": [
        "Markdown document at benchmarks/results/COMPARISON.md updated with actual data (no placeholders)",
        "Includes test setup: hardware info, Redis version, Docker config, app config, Haskell RTS flags, .NET runtime version",
        "Results tables for standalone showing requests/sec and latency p50/p95/p99 for all 4 scenarios",
        "Analysis section explaining WHY numbers differ covering multiplexing, serialization, GHC vs CLR, GC, HTTP framework, SQLite patterns",
        "If any scenario shows >3x difference: includes Fairness Audit subsection proving both apps do identical work",
        "Conclusions and recommendations for redis-client library improvements",
        "All data sourced from actual benchmark JSON files",
        "Typecheck passes"
      ],
      "priority": 6,
      "passes": false,
      "notes": ""
    }
  ]
}
