# Ralph Progress Log
Started: Wed Feb 11 17:51:37 PST 2026
---

## Codebase Patterns
- Build with `nix-shell --run "cabal build <target>"` for Haskell code
- For standalone Redis multiplexing: use `createMultiplexer client (receive client)` and `submitCommand mux (encodeCommandBuilder [...])`
- `encodeCommandBuilder` is re-exported from `Redis` module and takes `[ByteString]` of command args
- Build with `dotnet build` for C# code in benchmarks/dotnet-rest/
- The `redis-client:redis` library re-exports Multiplexer and MultiplexPool from `lib/redis/Redis.hs`
- `cabal.project` must include `benchmarks/haskell-rest` as a package
- Test with `make test` (requires nix-build, runs full E2E suite)
- Trailing commas before closing `}` in Haskell record syntax cause parse errors in nix-build GHC
- ClusterConfig has a `clusterUseMultiplexing` field that must be set explicitly
- For dynamic per-request data in autocannon benchmarks, use programmatic API with `setupRequest` callback (not CLI `-b` flag which is static)
- SQLite `email` field has UNIQUE constraint — benchmark POST requests must generate unique emails

## 2026-02-12 - US-001
- Created branch `ralph/fair-rest-benchmark` from `ralph/cluster-performance-parity`
- Checked out all benchmark files (benchmarks/dotnet-rest, haskell-rest, scripts, shared, results) from `ralph/rest-cache-benchmark`
- Added `benchmarks/haskell-rest` to `cabal.project`
- Fixed `clusterUseMultiplexing` field in haskell-rest Main.hs (was missing)
- Fixed trailing comma parse errors in test/ClusterE2E/Utils.hs and test/ClusterE2E/TopologyRefresh.hs
- Added `node_modules` to .gitignore
- Verified: `cabal build haskell-rest-benchmark` succeeds, `dotnet build` succeeds, Multiplexer/MultiplexPool available, all 19 E2E tests pass
- Files changed: cabal.project, .gitignore, benchmarks/*, tasks/*, test/ClusterE2E/Utils.hs, test/ClusterE2E/TopologyRefresh.hs
- **Learnings for future iterations:**
  - The `ralph/rest-cache-benchmark` branch didn't have multiplexing; `ralph/cluster-performance-parity` does
  - Redis module re-exports everything from Multiplexer and MultiplexPool modules
  - nix-build uses a different GHC than cabal build locally and is stricter about syntax
  - The haskell-rest benchmark depends on `redis-client:redis` sublibrary
---

## 2026-02-12 - US-002
- Updated Haskell REST benchmark app to use Multiplexer for standalone Redis mode
- Replaced `runRedis` (which used `evalStateT` with `ClientState`) with specific command functions: `cacheGet`, `cachePsetex`, `cacheDel`
- Standalone mode now creates a `Multiplexer` wrapping the `PlainTextClient` connection, enabling concurrent pipelined Redis commands
- Cluster mode still uses `runClusterCommandClient` (which already has built-in multiplexing via `MultiplexPool`)
- Removed unused `mtl` dependency from cabal file, removed `Control.Monad.State` and `Data.ByteString` imports
- Files changed: benchmarks/haskell-rest/src/Main.hs, benchmarks/haskell-rest/haskell-rest-benchmark.cabal
- **Learnings for future iterations:**
  - `createMultiplexer` takes a connected client and a receive action: `createMultiplexer client (receive client)`
  - `submitCommand mux (encodeCommandBuilder ["CMD", arg1, arg2])` is the pattern for sending commands through the multiplexer
  - `encodeCommandBuilder` takes `[ByteString]` and produces a `Builder.Builder` with RESP encoding
  - The `RedisCommands` typeclass can't be used directly with Multiplexer - need to manually encode commands
  - Use `finally` to ensure `destroyMultiplexer` is called on app shutdown
  - All 19 E2E tests pass after these changes
---

## 2026-02-12 - US-003
- Fixed POST benchmark to generate unique emails per request using autocannon's programmatic API
- Created `benchmarks/scripts/post-bench.js` — uses `setupRequest` callback to generate unique email per request (`bench_${Date.now()}_${counter}@test.com`)
- Updated `benchmarks/scripts/run-benchmarks.sh` — replaced static autocannon CLI POST call with `node post-bench.js` invocation
- The old approach used a static body with `bench_RAND@test.com` (RAND was never replaced), causing SQLite UNIQUE constraint violations on the email field after the first request
- Files changed: benchmarks/scripts/post-bench.js (new), benchmarks/scripts/run-benchmarks.sh
- **Learnings for future iterations:**
  - autocannon CLI (`-b` flag) sends the same body for every request — cannot generate unique values
  - autocannon programmatic API supports `setupRequest` callback per request in the `requests` array, which allows dynamic body generation
  - The `setupRequest` function receives `(req, context)` and must return the modified `req` object
  - SQLite `email` field has a UNIQUE constraint — all benchmark POST requests must have unique emails
  - Pattern for programmatic autocannon scripts: see `post-bench.js` and `mixed-bench.js` for examples
---
